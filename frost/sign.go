package frost

import (
	"io"

	"github.com/f3rmion/fy/group"
)

// SigningNonce holds the secret nonce values generated by a participant
// during round 1 of signing. These values must be kept secret and never reused.
type SigningNonce struct {
	// ID is the participant's identifier.
	ID group.Scalar

	// D is the hiding nonce (secret).
	D group.Scalar

	// E is the binding nonce (secret).
	E group.Scalar
}

// SigningCommitment is the public commitment broadcast by a participant
// during round 1 of signing.
type SigningCommitment struct {
	// ID is the participant's identifier.
	ID group.Scalar

	// HidingPoint is the public commitment to the hiding nonce (D * G).
	HidingPoint group.Point

	// BindingPoint is the public commitment to the binding nonce (E * G).
	BindingPoint group.Point
}

// SignatureShare is a participant's contribution to the final signature,
// produced during round 2 of signing.
type SignatureShare struct {
	// ID is the participant's identifier.
	ID group.Scalar

	// Z is the signature share value.
	Z group.Scalar
}

// SignRound1 generates fresh nonces and a public commitment for a signing
// session. The returned [SigningNonce] must be kept secret and passed to
// [FROST.SignRound2]. The returned [SigningCommitment] must be broadcast
// to all other signers.
//
// Each call to SignRound1 generates new random nonces. Nonces must never
// be reused across signing sessions.
func (f *FROST) SignRound1(r io.Reader, share *KeyShare) (*SigningNonce, *SigningCommitment, error) {
	d, err := f.group.RandomScalar(r)
	if err != nil {
		return nil, nil, err
	}
	e, err := f.group.RandomScalar(r)
	if err != nil {
		return nil, nil, err
	}

	nonce := &SigningNonce{
		ID: share.ID,
		D:  d,
		E:  e,
	}

	commitment := &SigningCommitment{
		ID:           share.ID,
		HidingPoint:  f.group.NewPoint().ScalarMult(d, f.group.Generator()),
		BindingPoint: f.group.NewPoint().ScalarMult(e, f.group.Generator()),
	}

	return nonce, commitment, nil
}

// SignRound2 computes this participant's signature share for the given message.
// It requires the participant's key share, their secret nonce from round 1,
// the message to sign, and all signing commitments from participating signers.
//
// The commitments slice must include commitments from all signers participating
// in this signing session (at least threshold signers).
func (f *FROST) SignRound2(
	share *KeyShare,
	nonce *SigningNonce,
	message []byte,
	commitments []*SigningCommitment,
) (*SignatureShare, error) {
	// Encode commitment list for binding factor computation
	encCommitList := f.encodeCommitments(commitments)

	// Compute binding factors for each signer using H1
	bindingFactors := f.computeBindingFactors(message, encCommitList, commitments)

	// Compute group commitment R = sum(D_i + rho_i * E_i)
	R := f.group.NewPoint()
	for _, comm := range commitments {
		rho := bindingFactors[string(comm.ID.Bytes())]
		rhoE := f.group.NewPoint().ScalarMult(rho, comm.BindingPoint)
		term := f.group.NewPoint().Add(comm.HidingPoint, rhoE)
		R = f.group.NewPoint().Add(R, term)
	}

	// Compute challenge c = H2(R, GroupKey, message)
	c := f.hasher.H2(f.group, R.Bytes(), share.GroupKey.Bytes(), message)

	// Compute Lagrange coefficient for this signer
	lambda := f.lagrangeCoefficient(share.ID, commitments)

	// Compute signature share: z_i = d + rho * e + lambda * s * c
	myRho := bindingFactors[string(share.ID.Bytes())]

	z := f.group.NewScalar().Mul(myRho, nonce.E)                // rho * e
	z = f.group.NewScalar().Add(nonce.D, z)                     // d + rho * e
	lambdaS := f.group.NewScalar().Mul(lambda, share.SecretKey) // lambda * s
	lambdaSC := f.group.NewScalar().Mul(lambdaS, c)             // lambda * s * c
	z = f.group.NewScalar().Add(z, lambdaSC)                    // d + rho*e + lambda*s*c

	return &SignatureShare{
		ID: share.ID,
		Z:  z,
	}, nil
}

// Aggregate combines individual signature shares into a complete Schnorr
// signature. The resulting signature can be verified using [FROST.Verify].
//
// All signature shares must be from the same signing session (same message
// and commitments).
func (f *FROST) Aggregate(
	message []byte,
	commitments []*SigningCommitment,
	shares []*SignatureShare,
) (*Signature, error) {
	// Encode commitment list and recompute R
	encCommitList := f.encodeCommitments(commitments)
	bindingFactors := f.computeBindingFactors(message, encCommitList, commitments)
	R := f.group.NewPoint()
	for _, comm := range commitments {
		rho := bindingFactors[string(comm.ID.Bytes())]
		rhoE := f.group.NewPoint().ScalarMult(rho, comm.BindingPoint)
		term := f.group.NewPoint().Add(comm.HidingPoint, rhoE)
		R = f.group.NewPoint().Add(R, term)
	}

	// Sum all z shares
	z := f.group.NewScalar()
	for _, s := range shares {
		z = f.group.NewScalar().Add(z, s.Z)
	}

	return &Signature{R: R, Z: z}, nil
}

// Verify checks whether a FROST signature is valid for the given message
// and group public key. Returns true if the signature is valid.
//
// This performs standard Schnorr signature verification:
// z*G == R + c*Y, where c = H2(R, Y, message).
func (f *FROST) Verify(message []byte, sig *Signature, groupKey group.Point) bool {
	// c = H2(R, GroupKey, message)
	c := f.hasher.H2(f.group, sig.R.Bytes(), groupKey.Bytes(), message)

	// Check: z*G == R + c*Y
	lhs := f.group.NewPoint().ScalarMult(sig.Z, f.group.Generator())

	cY := f.group.NewPoint().ScalarMult(c, groupKey)
	rhs := f.group.NewPoint().Add(sig.R, cY)

	return lhs.Equal(rhs)
}

// encodeCommitments serializes the commitment list for hashing.
// The encoding is: ID || HidingPoint || BindingPoint for each commitment.
func (f *FROST) encodeCommitments(commitments []*SigningCommitment) []byte {
	var commBytes []byte
	for _, c := range commitments {
		commBytes = append(commBytes, c.ID.Bytes()...)
		commBytes = append(commBytes, c.HidingPoint.Bytes()...)
		commBytes = append(commBytes, c.BindingPoint.Bytes()...)
	}
	return commBytes
}

// computeBindingFactors derives the binding factor for each signer from
// the message and all signing commitments using H1. This ensures that each
// signer's contribution is bound to the specific signing session.
func (f *FROST) computeBindingFactors(message, encCommitList []byte, commitments []*SigningCommitment) map[string]group.Scalar {
	factors := make(map[string]group.Scalar)

	for _, c := range commitments {
		rho := f.hasher.H1(f.group, message, encCommitList, c.ID.Bytes())
		factors[string(c.ID.Bytes())] = rho
	}

	return factors
}

// lagrangeCoefficient computes the Lagrange interpolation coefficient for
// the given participant ID within the set of signing participants.
// This is used to combine signature shares into a valid threshold signature.
func (f *FROST) lagrangeCoefficient(id group.Scalar, commitments []*SigningCommitment) group.Scalar {
	num := f.scalarFromInt(1)
	den := f.scalarFromInt(1)

	for _, c := range commitments {
		if c.ID.Equal(id) {
			continue
		}
		// num *= c.ID
		num = f.group.NewScalar().Mul(num, c.ID)
		// den *= (c.ID - id)
		diff := f.group.NewScalar().Sub(c.ID, id)
		den = f.group.NewScalar().Mul(den, diff)
	}

	denInv, _ := f.group.NewScalar().Invert(den)
	return f.group.NewScalar().Mul(num, denInv)
}
